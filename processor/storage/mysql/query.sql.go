// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package mysql

import (
	"context"
	"database/sql"
	"time"
)

const averageLatencyByService = `-- name: AverageLatencyByService :many
SELECT 
	s.id, 
	s.name, 
	ROUND(AVG(proxy_latency),   0)   AS avg_proxy_latency,
	ROUND(AVG(gateway_latency), 0) AS avg_gateway_latency,
	ROUND(AVG(request_latency), 0) AS avg_request_latency
	FROM  records 
	INNER JOIN services s ON records.service_id = s.id 
	GROUP BY service_id
`

type AverageLatencyByServiceRow struct {
	ID                string
	Name              string
	AvgProxyLatency   float64
	AvgGatewayLatency float64
	AvgRequestLatency float64
}

func (q *Queries) AverageLatencyByService(ctx context.Context) ([]AverageLatencyByServiceRow, error) {
	rows, err := q.db.QueryContext(ctx, averageLatencyByService)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AverageLatencyByServiceRow
	for rows.Next() {
		var i AverageLatencyByServiceRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.AvgProxyLatency,
			&i.AvgGatewayLatency,
			&i.AvgRequestLatency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRecord = `-- name: InsertRecord :execresult
INSERT INTO records (
	consumer_id,
	upstream_uri,
	response_id,
	request_id,
	route_id,
	service_id,
	proxy_latency,
	gateway_latency,
	request_latency,
	client_ip,
	started_at
) VALUES (
	?,?,?,?,?,?,?,?,?,?,?
)
`

type InsertRecordParams struct {
	ConsumerID     string
	UpstreamUri    string
	ResponseID     string
	RequestID      string
	RouteID        string
	ServiceID      string
	ProxyLatency   int64
	GatewayLatency int64
	RequestLatency int64
	ClientIp       string
	StartedAt      time.Time
}

func (q *Queries) InsertRecord(ctx context.Context, arg InsertRecordParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertRecord,
		arg.ConsumerID,
		arg.UpstreamUri,
		arg.ResponseID,
		arg.RequestID,
		arg.RouteID,
		arg.ServiceID,
		arg.ProxyLatency,
		arg.GatewayLatency,
		arg.RequestLatency,
		arg.ClientIp,
		arg.StartedAt,
	)
}

const insertRequest = `-- name: InsertRequest :execresult
INSERT INTO requests (
	id, method, uri, url, size, querystring,
	header_accept, header_host,
	header_user_agent
) VALUES (
	?,?,?,?,?,?,?,?,?
)
`

type InsertRequestParams struct {
	ID              string
	Method          string
	Uri             string
	Url             string
	Size            int64
	Querystring     string
	HeaderAccept    string
	HeaderHost      string
	HeaderUserAgent string
}

func (q *Queries) InsertRequest(ctx context.Context, arg InsertRequestParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertRequest,
		arg.ID,
		arg.Method,
		arg.Uri,
		arg.Url,
		arg.Size,
		arg.Querystring,
		arg.HeaderAccept,
		arg.HeaderHost,
		arg.HeaderUserAgent,
	)
}

const insertResponse = `-- name: InsertResponse :execresult
INSERT INTO responses (
	id, status, size, content_length,
	via, connection, access_control_allow_credentials,
	access_control_allow_origin, content_type, server
) VALUES (
	?,?,?,?,?,?,?,?,?,?
)
`

type InsertResponseParams struct {
	ID                            string
	Status                        int64
	Size                          int64
	ContentLength                 int64
	Via                           string
	Connection                    string
	AccessControlAllowCredentials string
	AccessControlAllowOrigin      string
	ContentType                   string
	Server                        string
}

func (q *Queries) InsertResponse(ctx context.Context, arg InsertResponseParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertResponse,
		arg.ID,
		arg.Status,
		arg.Size,
		arg.ContentLength,
		arg.Via,
		arg.Connection,
		arg.AccessControlAllowCredentials,
		arg.AccessControlAllowOrigin,
		arg.ContentType,
		arg.Server,
	)
}

const insertRoute = `-- name: InsertRoute :execresult
INSERT INTO routes (
	id,
	created_at,
	updated_at,
	hosts,
	methods,
	paths,
	preserve_host,
	protocols,
	regex_priority,
	service_id,
	strip_path
) VALUES (
	?,?,?,?,?,?,?,?,?,?,?
) ON DUPLICATE KEY UPDATE id=id
`

type InsertRouteParams struct {
	ID            string
	CreatedAt     time.Time
	UpdatedAt     time.Time
	Hosts         string
	Methods       string
	Paths         string
	PreserveHost  int32
	Protocols     string
	RegexPriority int64
	ServiceID     string
	StripPath     int32
}

func (q *Queries) InsertRoute(ctx context.Context, arg InsertRouteParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertRoute,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Hosts,
		arg.Methods,
		arg.Paths,
		arg.PreserveHost,
		arg.Protocols,
		arg.RegexPriority,
		arg.ServiceID,
		arg.StripPath,
	)
}

const insertService = `-- name: InsertService :execresult
INSERT INTO services (
	id,
	created_at,
	updated_at,
	host,
	name,
	path,
	port,
	protocol,
	read_timeout,
	write_timeout,
	connect_timeout,
	retries
) VALUES (
	?,?,?,?,?,?,?,?,?,?,?,?
) ON DUPLICATE KEY UPDATE id=id
`

type InsertServiceParams struct {
	ID             string
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Host           string
	Name           string
	Path           string
	Port           int64
	Protocol       string
	ReadTimeout    int64
	WriteTimeout   int64
	ConnectTimeout int64
	Retries        int64
}

func (q *Queries) InsertService(ctx context.Context, arg InsertServiceParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertService,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Host,
		arg.Name,
		arg.Path,
		arg.Port,
		arg.Protocol,
		arg.ReadTimeout,
		arg.WriteTimeout,
		arg.ConnectTimeout,
		arg.Retries,
	)
}
